#  Начнем описывать архитетуру с построения DFD диаграммы потоков информации с декомпозицией. DFD в данном случае лучше IDF или других стандартов, так как выгодно описывает взаимодействие сущностей в потоке.
##  Первый уровень
![DFD первый уровень декомпозиции](https://github.com/synestal/AvitoKostryukovAndy/blob/main/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0/DFD%20%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2%2C%201-%D1%8B%D0%B9%20%D1%83%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C%20%D0%B4%D0%B5%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%B8%20%D0%B2%20Ramus.jpg)

##  И второй уровень
![DFD второй уровень декомпозиции](https://github.com/synestal/AvitoKostryukovAndy/blob/main/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0/DFD%20%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2%2C%202-%D0%BE%D0%B9%20%D1%83%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C%20%D0%B4%D0%B5%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%B8%20%D0%B2%20Ramus.jpg)

Таким образом, можно увидеть три слоя работы программы - слой handler, слой functions и слой DAO (взаимодействия с бд).

##  Перейдем к детальному рассмотрению работы программы.
Из источника (например, браузера) приходит запрос на выбранный сокет, где работает программа. Далее, в зависимости от типа запроса и его заголовка, сам запрос пересылается в handler (обработчик запроса, слой handler). В сущности handler происходит изъятие информации из http запроса и необходимая проверка на целостность данных для конкретного типа водных данных (например, поле features равно слову, а не числу). На этом этапе может быть сгенерирован ответ об ошибке.
Далее обработчк вызывает сущности обработки запроса и ожидает ответа от нее. Затем функция обработки (слой functions) производит операции для удволетворения http-запроса, например, проверяет является человек админом и показывает баннер. В этом слое сообщаются ошибки и отправляются в handler как отдельный объект. Обращаясь к функции показа баннера, программа переходит к новому слою - слою DAO.
В слое DAO происходит общение с бд postgres. Выполняя все нужные запросы, слой DAO генерирует ответ и ошибку, которая потом передается слою functions, который передает ее header слою. Сам handler слой формирует ответ на основе error и answer из слоя functions конечному пользователю.

##Опишем схему бд postgres AvitoDB.

Изначально была выбрана модель разбития информации о баннере и о его фичах в две разные сущности.
![Схема бд, первая ревизия](https://github.com/synestal/AvitoKostryukovAndy/blob/main/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%91%D0%94%20postres%20%D0%B2%20Erwin.jpg)
Но она проиграла второму решению по скорости работы и простоте разработки кода, а так же, отсутствия необходимости решать проблемы связи многие-ко многим на физическом уровне БД, поэтому в проекте имплементируется именно второй подход.
![Схема бд, вторая ревизия](https://github.com/synestal/AvitoKostryukovAndy/blob/main/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20postgres%20%D1%84%D0%B8%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20Erwin.jpg)

Предполагается, что уже существует некая таблица, содержащая данные о пользователях и в нее заносит и изменяет данные другой сервис, но для простоты отладки и работы, был написан способ добавления нового пользователя с флагом - таблиа user_tokens.
В таблице banners_storage содержится вся информация о баннере и его фичах, тегах, времени обновления и прочем. В таблице history_banenrs содержится информация об истории баннера - 3 последних обновления и текущее состояние. В таблице delayed_deletions реализовано отложенное удаление
Подробнее о реализации работы функций - в основном readme
